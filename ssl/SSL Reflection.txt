Adding HTTPS to the local development environment didn’t change core app behavior, but it did introduce a layer of security that mirrors production conditions more closely. API requests, frontend routing, and authentication flows (like Firebase SSO) continued to work, though some browsers initially flagged the self-signed certificate as untrusted. This was resolved by importing the certificate into Windows' Trusted Root Certification Authorities and clearing HSTS settings.
The main setup challenge was ensuring both backend and frontend referenced the correct certificate paths and that the certificate matched the localhost domain. Once configured, the app ran securely on https://localhost, allowing for realistic testing of secure cookies, CORS policies, and mixed content warnings.
For production deployment, you'd need to replace the self-signed certificate with one issued by a trusted Certificate Authority (e.g., Let's Encrypt). SSL termination would typically be handled by a reverse proxy like NGINX or by your cloud provider. You’d also enforce HTTPS via HTTP Strict Transport Security (HSTS), redirect all HTTP traffic, and ensure your certificate auto-renews to avoid downtime
